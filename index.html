<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumping Dinosaur Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevents scrollbars from appearing */
        }
        /* Custom styles for the game canvas for a slightly retro feel */
        canvas {
            background-color: #f7f7f7;
            border-bottom: 2px solid #333;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center h-screen m-0">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full max-w-2xl mx-auto text-center p-4">
        <h1 class="text-2xl md:text-3xl text-gray-700 mb-2">Jumping Dino</h1>
        <p class="text-gray-500 mb-4">Press SPACE or TAP to Jump</p>
        
        <!-- Score Display -->
        <div id="score-container" class="absolute top-5 right-5 text-lg text-gray-600">
            SCORE: <span id="score">0</span>
        </div>
        
        <!-- Canvas where the game is drawn -->
        <canvas id="gameCanvas"></canvas>

        <!-- Game Over Screen (Initially Hidden) -->
        <div id="game-over-screen" class="hidden absolute inset-0 bg-gray-800 bg-opacity-75 flex flex-col items-center justify-center">
            <h2 class="text-4xl text-white mb-4">Game Over</h2>
            <p class="text-xl text-white mb-6">Your Score: <span id="final-score">0</span></p>
            <button id="restart-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-300">
                Restart
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const gameContainer = document.getElementById('game-container');

        // --- Game Configuration ---
        let canvasWidth = gameContainer.clientWidth;
        let canvasHeight = 300;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const groundHeight = 50;
        const dinoWidth = 40;
        const dinoHeight = 60;
        const dinoBottomOffset = 10; // Small gap below dino

        // --- Game State ---
        let score = 0;
        let gameSpeed = 5;
        let gameOver = false;
        let animationFrameId;
        let obstacles = [];
        let obstacleSpawnTimer = 0;
        let minObstacleInterval = 100; // Minimum frames between obstacles

        // --- Player (Dino) Object ---
        const dino = {
            x: 50,
            y: canvasHeight - groundHeight - dinoHeight - dinoBottomOffset,
            width: dinoWidth,
            height: dinoHeight,
            velocityY: 0,
            gravity: 0.6,
            jumpStrength: -15,
            isJumping: false,
            
            draw() {
                ctx.fillStyle = '#555'; // Dino color
                ctx.fillRect(this.x, this.y, this.width, this.height);
            },

            jump() {
                // Allow jumping only if on the ground
                if (!this.isJumping) {
                    this.velocityY = this.jumpStrength;
                    this.isJumping = true;
                }
            },

            update() {
                // Apply gravity
                this.velocityY += this.gravity;
                this.y += this.velocityY;

                // Prevent falling through the ground
                const groundLevel = canvasHeight - groundHeight - this.height - dinoBottomOffset;
                if (this.y > groundLevel) {
                    this.y = groundLevel;
                    this.velocityY = 0;
                    this.isJumping = false;
                }
                this.draw();
            }
        };

        // --- Obstacle Class ---
        class Obstacle {
            constructor(x, width, height) {
                this.x = x;
                this.y = canvasHeight - groundHeight - height;
                this.width = width;
                this.height = height;
            }

            draw() {
                ctx.fillStyle = '#d9534f'; // Obstacle color
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                this.x -= gameSpeed;
                this.draw();
            }
        }
        
        // --- Game Functions ---

        function spawnObstacle() {
            // Randomly determine obstacle size
            const height = Math.random() * 30 + 20; // Random height between 20 and 50
            const width = Math.random() * 10 + 20;  // Random width between 20 and 30
            
            // Create a new obstacle at the right edge of the canvas
            const obstacle = new Obstacle(canvasWidth, width, height);
            obstacles.push(obstacle);
        }

        function handleObstacles() {
            obstacleSpawnTimer++;
            // Spawn new obstacles at random intervals
            if (obstacleSpawnTimer > minObstacleInterval && Math.random() < 0.02) {
                spawnObstacle();
                obstacleSpawnTimer = 0;
            }

            // Update and draw each obstacle
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();

                // Collision detection
                if (
                    dino.x < obstacles[i].x + obstacles[i].width &&
                    dino.x + dino.width > obstacles[i].x &&
                    dino.y < obstacles[i].y + obstacles[i].height &&
                    dino.y + dino.height > obstacles[i].y
                ) {
                    endGame();
                }

                // Remove obstacles that have moved off-screen
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }

        function updateScore() {
            score++;
            scoreEl.textContent = Math.floor(score / 5); // Slow down visible score increase
            
            // Increase game speed over time to make it harder
            if (score % 200 === 0) {
                gameSpeed += 0.5;
                minObstacleInterval = Math.max(50, minObstacleInterval - 5); // Decrease spawn time
            }
        }
        
        function drawGround() {
            ctx.fillStyle = '#333';
            ctx.fillRect(0, canvasHeight - groundHeight, canvasWidth, groundHeight);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        }

        function resetGame() {
            // Reset all game variables to their initial state
            score = 0;
            gameSpeed = 5;
            obstacles = [];
            dino.y = canvasHeight - groundHeight - dino.height - dinoBottomOffset;
            dino.velocityY = 0;
            dino.isJumping = false;
            gameOver = false;
            
            // Hide the game over screen and start the game loop again
            gameOverScreen.classList.add('hidden');
            gameLoop();
        }

        function endGame() {
            gameOver = true;
            cancelAnimationFrame(animationFrameId); // Stop the game loop
            
            // Show the game over screen
            finalScoreEl.textContent = Math.floor(score / 5);
            gameOverScreen.classList.remove('hidden');
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if (gameOver) return;

            // Request the next frame
            animationFrameId = requestAnimationFrame(gameLoop);

            clearCanvas();
            drawGround();
            
            // Update and draw game elements
            dino.update();
            handleObstacles();
            updateScore();
        }

        // --- Event Listeners ---
        function handleJump(e) {
            // Prevent spacebar from scrolling the page
            if (e.code === 'Space') {
                e.preventDefault();
            }
            if (!gameOver) {
                dino.jump();
            }
        }
        
        window.addEventListener('keydown', handleJump);
        window.addEventListener('touchstart', () => {
             if (!gameOver) dino.jump();
        });
        restartButton.addEventListener('click', resetGame);

        // --- Responsive Canvas ---
        function resizeCanvas() {
            canvasWidth = gameContainer.clientWidth;
            canvas.width = canvasWidth;
            // Redraw ground on resize to ensure it spans the new width
            if (!gameOver) {
                drawGround();
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // --- Start Game ---
        gameLoop();
    </script>
</body>
</html>

